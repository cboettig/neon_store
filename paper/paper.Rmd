---
title: "taxadb: A High-Performance Local Taxonomic Database Interface"
author:
  - name: "Carl Boettiger"
    affiliation: ucb
  - name: "Christine Laney"
    affiliation: neon
  - name: "Quinn Thomas"
    affiliation: vt
address:
  - code: ucb
    address: "Dept of Environmental Science, Policy, and Management, University of California Berkeley, Berkeley CA 94720-3114, USA"
  - code: neon
    address: "NEON"
  - code: vt
    address: "Virginia Tech"
abstract: |
  The National Ecological Observatory Network
journal: "TBD"
date: "`r Sys.Date()`"
bibliography: refs.bib
layout: 3p
header-includes:
   - \usepackage{lineno}
   - \linenumbers
output: rticles::elsevier_article
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  cache = TRUE
)
library(neonstore)
Sys.setenv("NEONSTORE_HOME" = tempfile())
```

The National Ecological Observatory Network (NEON) provides open access ecological data as 181 (active and planned) data products at 81 (permanent and relocatable) sites throughout the United States.  The `neonstore` R package seeks to provide quick, convenient access and persistent storage of NEON data files.  `neonstore` design emphasizes simplicity and data provenance. Here, we describe the design, use, and rationale for the package.

## Rationale and package design

NEON data products are built around a highly atomized file design: both observation systems (OS) and instrument systems (IS) data products are divided into separate files by site and month.  Meanwhile, products generated by the airborne observation platform (AOP) are typically divided by type, flight date, flight line, and grid cell.  This atomized approach facilitates sub-setting and data transfer, because users can identify ahead of time which products, locations, and time ranges they need. As some NEON data products can be quite large (NEON's data catalog to date is in excess of 1 petabyte, primarily due to the size of many AOP products), being able to only download or only read into R the files of interest is already important to save bandwidth or computer memory, and this will be increasingly true as NEON data accumulates in the years ahead. This approach also facilitates data provenance and reproducibility, because it means that an update or correction to data collected at a particular site and time results only in a change to a single file and not the whole data product. Users can easily verify whether or not the update has changed data in their analyses by comparing file hashes, rather than having to read in and examine data meticulously row by row.  

However, the highly atomized structure of NEON's data can also become a barrier to entry without convenient tools for working
with many files.  Most analyses will inevitably require multiple files to be combined or stacked, e.g. to create a unified record for a product across many months or years of sampling or across many sites.  When the process of combining files is complex or slow to execute, many researchers will resort to saving the resulting 'stacked' products as a basis for future work.  Such workflows may be more cumbersome to update as additional data continues to be published, or to compare against any subsequent corrections to previously-published data.  `neonstore` seeks to help users download and manage NEON files locally in a way that
lets analyses be quickly traced back to the raw data files.

`neonstore` is distinguished as much by what it does not do as by what it does.  All `neonstore` operations are intended to be transparent and intuitive, and could easily be duplicated in another computational language or command line interface. Specifically, `neonstore` will never automatically "clean" data: opaque data transformations make output sensitive to the version and implementation details of the tool in question.  A user should expect the same file from a "download" operation regardless of the software or software version used to perform the download.  Functions which in read in the data should faithfully reproduce the raw data so that analyses can easily be compared to those using other software tools. When functions perform tasks like guessing the data type (numeric, string, Date, etc) of a column, or adding additional columns to stack two otherwise matching tables in which one has recorded an additional variable, they should do so in a manner that is transparent, controllable, and consistent with the behaviour of common functions used in the language. 


## `neonstore` Functionality


`neonstore` functionality can be divided into two halves: functions that interface with the NEON Application Programming Interface (API), and functions for working with a local store of previously-downloaded NEON files.  


```{r}
library(neonstore)
```

### NEON API functions

`neon_products()` and `neon_sites()` bind the NEON REpresentational State Transfer (REST) API endpoints for `/products` and `/sites`, providing information about each as a data frame. This can be useful for product discovery and occassionally for referencing other useful metadata about products and sites.  Each of these functions requires only a single API call (see discussion of rate limiting below).

```{r}
products <- neon_products()
products
```

```{r}
sites <- neon_sites()
sites
```

The workhorse function of `neonstore` is `neon_download()`, which downloads all files identified by a given product code, optionally constrained to specific site, date range, or file name pattern.  For instance, we can download all of the NEON landbird survey data, identified as NEON data product `DP1.10003.001`: 

```{r}
neon_download("DP1.10003.001")
```

To download this data, `neon_download()` must make many API calls.  It first uses `neon_sites()` to reference all sites containing this data product.  Then for each site, for each month for which that site collected data, the function will make an API call to the `/data` endpoint (using the `neonstore` function, `neon_data()`), which returns a table of files found for that product at the requested site and month range.  The  table from `neon_data()` indicates 4 values: the file name, the MD5 hash of the data file (confusingly labeled as the crc32 sum, though CRC32 hashes are used only for AOP data products.  Note that MD5 hashes are length-32 character strings, while the CRC32 hashes are 8 characters long), the file size (in bytes -- encoded as a character because some file sizes are too long to be represented as an integer), and a download URL.  The download URL embeds a temporary access token which expires after an hour, so users must complete all the downloads before this time expires.  The access string for each file is unique, thus it is (at the time of writing) impossible to download any given data file without making a corresponding API request, even if the precise file name and address is already known.  



The three-digit code identifies this as a Level 1 data product (DP1), product number 10003, revision 001, indicating this is the first and so far the only protocol used for bird survey sampling.   


Now, view your store of NEON products:

```{r }
neon_store()
```

These will persist between sessions, so you only need to download once
or to retrieve updates. `neon_store()` can take arguments to filter by product
or pattern in table name, e.g. `neon_store(table = "brd")`.

Once you determine the table of interest, you can
read in all the component tables into a single `data.frame`

```{r}
neon_read("brd_countdata-expanded")
```

Two other functions access additional API endpoints 
that may also be of interest. `neon_sites()` returns a `data.frame`
of site information, including site descriptions and 
the ecological domain that each site falls into:


```{r}
neon_sites()
```

Lastly, `neon_products()` returns a table with a list of all neon products,
which may be useful for data discovery or additional metadata about any
given product:  


```{r}
neon_products()
```

Note that at this time, `neonstore` does not provide a complete 


## Design Details / comparison to `neonUtilities`

`neonstore` is not meant as a replacement to the `neonUtilities` package
developed by NEON staff.  `neonUtilities` performs a range of product-specific
data querying, parsing, and data manipulation beyond what is provided by NEON's
API or web interface. `neonUtilities` also provides other utilities for working 
with NEON data beyond the scope of the NEON API or the data download/ingest 
process. While this processing is undoubtedly useful, it may make
it difficult to compare results or analyses based on data downloaded and accessed
using `neonUtilities` R package with analyses based on data accessed directly
from the web interface, the API, or another tool (or even a different release
of the `neonUtilities`).

By contrast, `neonstore` aims to do far less.  `neonstore` merely automates the
download of individual NEON data files.  In contrast to `neonUtilities` which 
by default "stacks" these raw files into single tables and discards the raw 
data, `neonstore` preserves only the raw files in the store, stacking the 
individual tables "on demand" using `neon_read()`. `neon_read()` is a thin
wrapper around the `vroom` package, 
[Hester & Wickham, 2020](https://vroom.r-lib.org), which uses the `altrep` 
mechanism in R to provide very fast reads of rectangular text data into R,
and trivially handles the case of a single table being broken across many files.
Some NEON tables are not entirely consistent in their use of columns across the
individual site-month files, so `neon_read()` transparently checks for this,
reading in groups of files sharing all matching columns with `vroom` before
binding the groups together. This makes it easier to always trace an analysis
back to the original input data, makes it easier to update input data files 
without facing the challenge of either downloading & stacking the whole 
data product from scratch again or having to keep track of some previously
downloaded data file.

A few other differences are also worth noting.

- `neonstore` aims to provide persistent storage, writing raw data files to
  the appropriate app directory for your operating system (see `rappdirs`,
  [Ratnakumar et al 2016](https://CRAN.R-project.org/package=rappdirs)). 
  More details about this can be found in [Provenance](/#Provenance), below.
- `neon_download()` provides  clean and concise progress bars for the two key
  processes involved: querying the API to obtain download URLs (which involves no 
  large data transfer but counts against API rate limiting, see below), and the
  actual file downloads.
- `neon_download()` will verify the integrity of file downloads against the MD5
  hashes provided. 
- `neon_download()` will omit downloads of any existing data files in the local 
  store.  
- You can request multiple products at once using vector notation, though API
  rate limiting may interfere with large requests.
- `neon_download()` uses `curl::curl_download()` instead of `downloadr` package
  used in `neonUtilities`, which can be finicky on Windows and older versions of R. 
- `neonstore` has slightly lighter dependencies: only `vroom` and `httr`, and
  packages already used by one of those two (`curl`, `openssl`).



Like `neonUtilities`, You can optionally include site and date filters,
e.g. to request only records more  recent than a certain date.  Doing so will
preserve API quota and improve speed (see API limits, below). `neonUtilities`
is also far more widely tested and has extensive error handling tailored to
individual data products.  


## Provenance

Because `neonstore` only stores raw data products as returned from the NEON API,
it can easily determine which files have already been downloaded, and only
download new files without requiring the user to specify specific dates. 
(It must still query the API for all the metadata in the requested date range).
This same modular approach also makes it easy to track _data provenance_, an 
essential element of reproduciblity in comparing results across other analyses
of the NEON data. 

We can list precisely which component files are being read in by `neon_read()`
by consulting `neon_index()`:


```{r}
raw_files <- neon_index(table = "brd_countdata-expanded", hash="md5")
raw_files
```

`neon_read()` is a relatively trivial function that simply passes this file 
list to `vroom::vroom()`, a fast, vectorized parser that can easily read in 
a single table that is broken into many separate files.  


Imagine instead that we use the common pattern of downloading
these raw files, stacks and possibly cleans the data, saving only this derived
product while discarding the individual files.  Now imagine a second researcher,
at some later date, queries the API over the same reported range of dates and 
sites, uses the same software package to stack the tables, only to discover the
resulting table is somehow different from ours (e.g. by comparing file hashes).
Pinpointing the source of the discrepancy would be challenging and 
labor-intensive.

In contrast, the same detective-work would be easy with the `neonstore` file
list.  We can confirm if the API had returned the same number of 
raw files with the same names; and better, can verify integrity of the contents
by comparing hashes of files now being returned to those recorded
by `neon_index()`.  In this way, we could determine if any additional files
had been included or pinpoint any files that may have changed.


As such, users might want to store the `neon_index()` `data.frame` for the
table(s) they have used as part of their analysis, including the individual
file hashes.  One can also generate a zip of all the data files for 
archival purposes. (Note that NEON is an Open Data provider, see
[LICENCE](https://www.neonscience.org/data/about-data/data-policies).)

```{r message=FALSE}
write.csv(raw_files, "index.csv")
zip("brd_countdata.zip", raw_files$path)
```

## Data citation

Always remember to cite your data sources!
`neonstore` knows how to generate the appropriate citation for the data
in your local store (or any specific product).

```{r}
## Note: NEON's recommendation may soon change
neon_citation()
```

## Note on API limits

[The NEON API now rate-limits requests.](https://data.neonscience.org/data-api/rate-limiting/#api-tokens).
Using a personal token will increase the number of requests you can make.
See that link for directions on registering for a token.
Then pass this token in `.token` argument of `neon_download()`,
or for frequent use, add this token as  an environmental variable, `NEON_DATA`
to your local `.Renviron` file in your user's home directory.  

`neon_download()` must first query each the API of eacn NEON site which collects
that product, for each month the product is collected.
(It would be much more efficient on the NEON server if the API could take
queries of the from `/data/<product>/<site>`, and pool the results, rather than
require each month of sampling separately!)

```{r include=FALSE}
unlink("brd_countdata.zip")
unlink("index.csv")
Sys.unsetenv("NEONSTORE_HOME")
```

## Non-stacking files and low-level interface

At it's core, `neonstore` is simply a mechanism to download files from the NEON API.
While the `.csv` files from the Observation Systems (OS, e.g. bird count surveys),
and Instrument Systems (e.g. aquatic sensors) are typically stacked into large
tables, other products, such as the `.laz` and `.tif` images produced by the
airborne observation platform LIDAR and cameras may require a different approach.



```{r}
# Read in a large file list for illustration purposes
cper_data <- readr::read_csv("https://minio.thelio.carlboettiger.info/shared-data/neon_data_catalog.csv.gz")

## Typically one would read all files in local store, e.g. list.file(neon_dir())
df <- neon_filename_parser(cper_data$name)
```

```{r}
library(dplyr)
df %>% count(EXT, sort=TRUE)
```

We can take a look at all `laz` LIDAR files:

```{r}
df %>% 
  filter(EXT == "laz")
```

Note that many of the airborne observation platform (AOP) products, such as
these LIDAR files, do not include the PRNUM or REV components that make up part
of the `productCode`s used in the NEON `product` tables.  


